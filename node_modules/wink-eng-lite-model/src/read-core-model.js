/* eslint-disable no-console */
/* eslint-disable no-sync */
/* eslint-disable guard-for-in */

const HeaderSize = 48;
const HeaderBufferSize = HeaderSize * 4;

var fs = require( 'fs' );

var readModel = function ( file ) {
  // File Descriptor.
  var fd;
  // Header block.
  var header = new Uint32Array( HeaderSize );
  // Packing information block.
  var packing;
  // Lexicon block.
  var lexicon;
  // Features data block.
  var featuresData;
  // `xpansions` of contractions.
  var xpansions;
  // Token Categories.
  var tcat;
  // Part Of Speech.
  var pos;
  // Tokenizer Regexes.
  var trex;
  // Hyphenation preservation rules.
  var preserve;
  // Returned: model.
  var model = Object.create( null );


  var readBlock = function ( target, targetSize, targetName, parse ) {
    var size = -1;
    var parsed = null;
    try {
      size = fs.readSync( fd, target, 0, targetSize );
    } catch ( ex ) {
      throw Error( 'Read Model: incorrect input – read failure at: ' + targetName + '\n\t' + ex.message );
    }
    if ( size !== targetSize ) throw Error( 'Read Model: incorrect input length found for: ' + targetName );

    if ( parse ) {
      try {
        parsed = JSON.parse( target.toString( 'utf8' ) );
      } catch ( ex ) {
        throw Error( 'Read Model: incorrect format – parse failure at: ' + targetName + '\n\t' + ex.message );
      }
    }

    return ( ( parsed ) ? parsed : target );
  }; // readBlock()

  // Open the model file in read mode.
  try {
    fd = fs.openSync( file, 'r' );
  } catch ( ex ) {
    throw Error( 'Read Model: file open failure\n\t' + ex.message );
  }

  // Read the header block first.
  header = readBlock( header, HeaderBufferSize, 'header', false );

  // Read the packing information block.
  packing = readBlock( ( Buffer.alloc( header[ 2 ] ) ), header[ 2 ], 'packing', true );

  // With header in hand, can allocate memory to lexicon.
  lexicon = new Uint32Array( header[ 3 ] / 4 );
  // Read the lexicon block.
  lexicon = readBlock( lexicon, header[ 3 ], 'lexicon', false );

  // Read the features data block.
  featuresData = readBlock( ( Buffer.alloc( header[ 4 ] ) ), header[ 4 ], 'features', true );
  // Rebuild hash from list for the required features.
  for ( const f in packing.layout ) {
    if ( packing.layout[ f ][ 3 ] === 0 ) {
      featuresData[ f ].hash = Object.create( null );
      for ( let k = 0; k < featuresData[ f ].list.length; k += 1 ) featuresData[ f ].hash[ featuresData[ f ].list[ k ] ] = k;
    }
  }
  // Rebuilding hash from lexeme is mandatory.
  featuresData.lexeme.hash = Object.create( null );
  for ( let k = 0; k < featuresData.lexeme.list.length; k += 1 ) featuresData.lexeme.hash[ featuresData.lexeme.list[ k ] ] = k;

  // Read `tcat`.
  tcat = readBlock( ( Buffer.alloc( header[ 5 ] ) ), header[ 5 ], 'tcat', true );
  // Read `pos`.
  pos = readBlock( ( Buffer.alloc( header[ 6 ] ) ), header[ 6 ], 'pos', true );
  // Read `trex`.
  trex = readBlock( ( Buffer.alloc( header[ 7 ] ) ), header[ 7 ], 'trex', true );
  // Read `xpansions` of contractions; treatment is similar to `lexicon` (above).
  xpansions = new Uint32Array( header[ 8 ] / 4 );
  xpansions = readBlock( xpansions, header[ 8 ], 'xpansions', false );
  // Read `preserve`.
  preserve = readBlock( ( Buffer.alloc( header[ 9 ] ) ), header[ 9 ], 'preserve', true );

  model.packing = packing;
  model.lexicon = lexicon;
  model.features = featuresData;
  model.tcat = tcat;
  model.pos = pos;
  model.trex = trex;
  model.xpansions = xpansions;
  model.preserve = preserve;
  return model;
}; // readModel()

module.exports = readModel;
