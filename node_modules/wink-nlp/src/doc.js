/* eslint-disable no-underscore-dangle */
/* eslint-disable no-console */

var constants = require( './constants.js' );
var search = require( './search.js' );
var containedEntities = require( './contained-entities.js' );
var its = require( './its.js' );

// Size of a single token.
var tkSize = constants.tkSize;
// Mask for preceding spaces.
var psMask = constants.psMask;
// Bits reserved for `lemma`.
var bits4lemma = constants.bits4lemma;
// Mask for extracting pos
var posMask = constants.posMask;

// # Helper Functions

// ## Output string

// ### stringOut
/**
 *
 * Outputs a string reconstructed using token numbers from the `start` to the `end.`
 *
 * @param {number} start index of the first token.
 * @param {number} end index of the last token.
 * @param {number[]} tokens the tokens-data-structure.
 * @param {function} value function as extracted from `cache`.
 * @returns {object} the reconstructed string.
 * @private
*/
var stringOut = function ( start, end, tokens, value ) {
  // Preceeding spaces & tokens.
  var pSpcTkns = [];

  for ( let i = start * tkSize; i <= end * tkSize; i += tkSize ) {
    const t = tokens[ i ];
    pSpcTkns.push( ''.padEnd( tokens[ i + 1 ] & psMask ), value( t ) );  // eslint-disable-line no-bitwise
  }
  return pSpcTkns.join( '' ).trim();
}; // stringOut()

// ### markedUpText
/**
 *
 * Constructs the marked up text from tokens-data-structure using the `markings`.
 *
 * @param {number[]} tokens The tokens-data-structure.
 * @param {array} markings index of the last token.
 * @param {function} value The value function as extracted from `cache`.
 * @returns {string} the marked up text.
 * @private
*/
var markedUpText = function ( tokens, markings, value ) {
  // Tokens with preceding spaces.
  var twps = [];

  // Build `twps` array from `tokens` by inserting "preceding spaces" & "value"
  // pairs.
  for ( let i = 0; i < tokens.length; i += tkSize ) {
    const t = tokens[ i ];
    twps.push( ''.padEnd( tokens[ i + 1 ] & psMask ), value( t ) );  // eslint-disable-line no-bitwise
  }

  // For every marking prefix the `first` one with `beginMarker` and suffix
  // the `last` one with `endMarker`.
  for ( let i = 0; i < markings.length; i += 1 ) {
    const first = ( markings[ i ][ 0 ] * 2 ) + 1;
    const last = ( markings[ i ][ 1 ] * 2 ) + 1;
    const beginMarker = ( markings[ i ][ 2 ]  === undefined ) ? '<mark>' : markings[ i ][ 2 ];
    const endMarker = ( markings[ i ][ 3 ]  === undefined ) ? '</mark>' : markings[ i ][ 3 ];

    twps[ first ] = beginMarker + twps[ first ];
    twps[ last ] += endMarker;
  }

  // Join all the elements and return the `markedUpText`.
  return twps.join( '' ).trim();
}; // markedUpText()

// <hr/>

// ## Output Array

// ### tokensOut
/**
 *
 * Outputs an array of tokens, mapped using `f` function using token numbers from
 * the `start` to the `end.`
 *
 * @param {number} start The start index of the first token.
 * @param {number} end The end index of the last token.
 * @param {number[]} tokens The tokens-data-structure.
 * @param {object} cache The nlp cache.
 * @param {function} f The function used to map each token.
 * @returns {array} the array of mapped tokens.
 * @private
*/
var tokensOut = function ( start, end, tokens, cache, f ) {
  // Mapped tokens.
  var mappedTkns = [];
  var fn = ( typeof f === 'function' ) ? f : its.value;

  for ( let i = start; i <= end; i += 1 ) {
    mappedTkns.push( fn( i, tokens, cache ) );
  }
  return mappedTkns;
}; // tokensOut()

// ### selTokensOut
/**
 *
 * Outputs an array of tokens, mapped using `f` function using token numbers (i.e. indexes) from
 * the selected tokens.
 *
 * @param {number[]} selTokens The array containing the indexes of selected tokens.
 * @param {number[]} tokens The tokens-data-structure.
 * @param {object} cache The nlp cache.
 * @param {function} f The function used to map each token.
 * @returns {array} the array of mapped tokens.
 * @private
*/
var selTokensOut = function ( selTokens, tokens, cache, f ) {
  var tkns = [];
  var fn = f;
  if ( typeof fn !== 'function' ) fn = its.value;
  for ( let i = 0; i < selTokens.length; i += 1 ) {
    tkns.push( fn( selTokens[ i ], tokens, cache ) );
  }
  return tkns;
}; // selTokensOut()

// ### entitiesOut
/**
 *
 * Outputs an array of all the entities present in the array `entities`.
 * Each element in the array is an entity represented as object with `text` and
 * `type` properties.
 *
 * @param {array} entities The array containing the entities.
 * @param {number[]} tokens The tokens-data-structure.
 * @param {object} cache The nlp cache.
 * @returns {object[]} the array of entitiy objects.
 * @private
*/
var entitiesOut = function ( entities, tokens, cache ) {
  var ents = [];
  for ( let i = 0; i < entities.length; i += 1 ) {
    ents.push( {
      text: stringOut( entities[ i ][ 0 ], entities[ i ][ 1 ], tokens, cache.value ),
      type: entities[ i ][ 2 ]
    } );
  }
  return ents;
}; // entitiesOut()

// ### selEntitiesOut
/**
 *
 * Outputs an array of the selected entities present in the array `selEntities`.
 * Each element in the array is an entity represented as object with `text` and
 * `type` properties.
 *
 * @param {array} selEntities The array containing the indexes of selected entities.
 * @param {array} entities The array containing the entities.
 * @param {number[]} tokens The tokens-data-structure.
 * @param {object} cache The nlp cache.
 * @returns {object[]} the array of entitiy objects.
 * @private
*/
var selEntitiesOut = function ( selEntities, entities, tokens, cache ) {
  var ents = [];
  var selEnt;
  var i;
  for ( i = 0; i < selEntities.length; i += 1 ) {
    selEnt = selEntities[ i ];
    ents.push( {
      text: stringOut( entities[ selEnt ][ 0 ], entities[ selEnt ][ 1 ], tokens, cache.value ),
      type: entities[ selEnt ][ 2 ]
    } );
  }
  return ents;
}; // selEntitiesOut()

// ### sentencesOut
/**
 *
 * Outputs an array of all the sentences present in the array `sentences`.
 * Each element in the array is a senetnce represented as string.
 *
 * @param {array} sentences The array containing the sentences.
 * @param {number[]} tokens The tokens-data-structure.
 * @param {object} cache The nlp cache.
 * @returns {string[]} the array of strings.
 * @private
*/
var sentencesOut = function ( sentences, tokens, cache ) {
  var sents = [];
  for ( let i = 0; i < sentences.length; i += 1 ) {
    sents.push( stringOut( sentences[ i ][ 0 ], sentences[ i ][ 1 ], tokens, cache.value ) );
  }
  return sents;
}; // sentencesOut()

// <hr/>

// ## Output on console

// ### printTokens
/**
 *
 * Prints a table of tokens along with their properties on console.
 *
 * @param {number[]} tokens The tokens.
 * @param {object} cache The language `cache`.
 * @returns {void} Nothing!
 * @private
*/
var printTokens = function ( tokens, cache ) {
  var imax = tokens.length;
  var i, j;
  var t, tv;
  var pad = '                         ';
  var str;
  var props = [ 'prefix', 'suffix', 'shape', 'lutCase', 'nerHint', 'tokenType' ];

  // Print header.
  console.log( '\n\ntoken      p-spaces   prefix  suffix  shape   case    nerHint type     normal/pos' );
  console.log( '———————————————————————————————————————————————————————————————————————————————————————' );
  for ( i = 0; i < imax; i += tkSize ) {
    str = '';
    t = tokens[ i ];
    tv = cache.value( t );
    str += ( JSON.stringify( tv ).replace( /"/g, '' )  + pad ).slice( 0, 18 );
    str += ( ( tokens[ i + 1 ] & psMask ) + pad ).slice( 0, 4 );  // eslint-disable-line no-bitwise
    for ( j = 0; j < props.length; j += 1 ) {
      str += ( JSON.stringify( cache.property( t, props[ j ] ) ).replace( /"/g, '' ) + pad ).slice( 0, 8 );
    }
    if ( tokens[ i + 1 ] > 65535 ) {
      str += ' ' + cache.value( cache.nox( tokens[ i + 1 ] ) ); // eslint-disable-line no-bitwise
      str += ' / ' + cache.valueOf( 'pos', ( tokens[ i + 2 ] & posMask ) >>> bits4lemma ); // eslint-disable-line no-bitwise
    } else {
      str += ' ' + JSON.stringify( cache.value( cache.normal( t ) ) ).replace( /"/g, '' );
      str += ' / ' + cache.property( t, 'pos' );
    }

    // str += '/' + cache.property( t, 'nerHint' );  // eslint-disable-line no-bitwise
    console.log( str );
    // Not being used as of now; to use move it before the console.log!
    str += ' / ' + cache.valueOf( 'pos', ( tokens[ i + 2 ] & posMask ) >>> bits4lemma );  // eslint-disable-line no-bitwise
  }

  // Print total number of tokens.
  console.log( '\n\ntotal number of tokens: %d', tokens.length / tkSize );
}; // printTokens()

// # Doc
/**
 *
 * The wink-nlp **doc**ument – constructed in `wink-nlp.js` – publishes the
 * developer APIs.
 *
 * @param {object} docData encapsulates the document data.
 * @return {object} conatining APIs.
 * @private
*/
var doc = function ( docData ) {
  // Extract `cache` as it is frequently accessed.
  var cache = docData.cache;
  // Extract `value` from `cache` as it is used frequently.
  var value = cache.value;

  // Document's tokens; each token is represented as an array of numbers:
  // ```
  // [
  //   hash, // of tokenized lexeme
  //   (nox) + preceding spaces, // expansion's normal
  //   pos + lemma, // pos & lemma are contextual
  //   entity + sentence // 12bit + 20bits
  // ]
  // ```
  var tokens = docData.tokens;

  // Entities — sorted as array of `[ start, end, entity type ].`
  var entities = docData.entities;

  // Sentences — sorted as array of pairs of `[ start, end ]` pointing to the `tokens`.
  var sentences = docData.sentences;

  // Markings are 4-tuples of `start`, `end` **token indexes**,  and `begin & end markers`.
  // The begin & end markers are used to markup the tokens specified.
  var markings = docData.markups;


  // #### API core functions:

  // Collection APIs.
  var colEntities;
  var colTokens;
  var colSentences;

  // Selection — obtained via `filter` — APIs. It is also like a collection.
  var colSelectedEntities;
  var colSelectedTokens;

  // Item APIs.
  var itemToken;
  var itemEntity;
  var itemSentence;

  // Others.
  var isLexeme;

  // The Document — Returned!
  var methods = Object.create( null );

  // *Returns a function to return a string constructed using tokens from `start` to `end`.*
  var out = function ( start, end ) {
    return (
      function () {
        return stringOut( start, end, tokens, value );
      }
    );
  }; // out()

  // *Returns a function to return a object constructed using entity at `index`.*
  var eOut = function ( index ) {
    return (
      function () {
        return {
          text: stringOut( entities[ index ][ 0 ], entities[ index ][ 1 ], tokens, value ),
          type: entities[ index ][ 2 ]
        };
      }
    );
  }; // eOut()

  // ## Token
  // **Item, Collection, and Selection APIs.**

  // ### itemToken
  /**
   *
   * Makes item of the token specified at `index`.
   *
   * @param {number} index The index of the token, which is required to be returned as item token.
   * @returns {object} containing applicable API methods.
   * @private
  */
  itemToken = function ( index ) {
    // Finds the parent entity item and returns, which may be `null` if the input
    // token (`index`) is not a part of any entity.
    var entity = function () {
      var k = search( index, entities );
      if ( k === null ) return undefined;
      return itemEntity( k );
    }; // entity()

    // Finds the parent sentence item and returns.
    var sentence = function () {
      var k = search( index, sentences );
      return itemSentence( sentences[ k ][ 0 ], sentences[ k ][ 1 ] );
    }; // sentence()

    // Return the applicable APIs.
    return (
        {
          // Access the parent document.
          document: () => methods,
          // Access the parent entity, **if any.**
          entity: entity,
          // Markup this token.
          markup: ( beginMarker, endMarker ) => markings.push( [ index, index, beginMarker, endMarker ] ),
          // Output this token or its properties using input function — `f`.
          out: ( f ) => ( ( typeof f === 'function' ) ? f( index, tokens, cache ) : its.value( index, tokens, cache ) ),
          // Access the parent sentence.
          sentence: sentence
        }
    );
  }; // itemToken()

  // ### colSelectedTokens
  /**
   *
   * Makes collection of tokens identified by the `selectedTokens` array.
   *
   * @param {array} selectedTokens The array of selected tokens, using which the
   * collection is made.
   * @returns {object} containing applicable API methods.
   * @private
  */
  colSelectedTokens = function ( selectedTokens ) {
    // Each iterator on `selectedTokens`.
    var each = function ( f ) {
      for ( let k = 0; k < selectedTokens.length; k += 1 ) {
        f( itemToken( selectedTokens[ k ] ), k );
      }
    }; // each()

    // Executes the reducer function — `f` on each element of `selectedTokens` array.
    var reduce = function ( f, initValue ) {
      var returnValue = initValue;
      for ( let k = 0; k < selectedTokens.length; k += 1 ) {
        returnValue = f( returnValue, itemToken( selectedTokens[ k ] ), k, selectedTokens.length );
      }
      return returnValue;
    }; // reduce()

    // Return the applicable APIs.
    return (
      {
        // Iterator.
        each: each,
        // Item at `k`th index. If `k` is outside valid range, return `undefined` like JS.
        itemAt: ( k ) => ( ( k < 0 || k >= selectedTokens.length ) ? undefined : itemToken( selectedTokens[ k ] ) ),
        // Number of selected tokens.
        length: () => ( selectedTokens.length ),
        // Output this collection of selected tokens as an array of their values or properties using input function — `f`.
        out: ( f ) => selTokensOut( selectedTokens, tokens, cache, f ),
        // Reduce executor.
        reduce: reduce
      }
    );
  }; // colTokens()

  // ### colTokens
  /**
   *
   * Makes collection of tokens beginning from `start` index to `end` index.
   *
   * @param {number} start The start index.
   * @param {number} end The end index.
   * @returns {object} containing applicable API methods.
   * @private
  */
  colTokens = function ( start, end ) {
    // Each iterator on this collection.
    var each = function ( f ) {
      for ( let k = start; k <= end; k += 1 ) {
        // Use relative indexing by adding `start` from `k`.
        f( itemToken( k ), ( k - start ) );
      }
    }; // each()

    // The filter() method creates a new collection with all tokens that pass
    // the test implemented by the input function — `f`.
    var filter = function ( f ) {
      var filtered = [];
      for ( let k = start; k <= end; k += 1 ) {
        // Use relative indexing by adding `start` from `k`.
        if ( f( itemToken( k ), ( k - start ) ) ) filtered.push( k );
      }
      return colSelectedTokens( filtered );
    }; // filter()

    // Executes the reducer function — `f` on each element this collection.
    var reduce = function ( f, initValue ) {
      var returnValue = initValue;
      for ( let k = start; k <= end; k += 1 ) {
        // Use relative indexing by adding `start` from `k`.
        returnValue = f( returnValue, itemToken( k ), ( k - start ), end - start + 1 );
      }
      return returnValue;
    }; // reduce()

    return (
      function () {
        return {
          // Iterator.
          each: each,
          // Filter.
          filter: filter,
          // Item at `k`th index. If `k` is outside valid range, return `undefined` like JS.
          // Also use relative indexing by adding `start` as it can be reached via entity or sentence.
          itemAt: ( k ) => ( ( k < 0 || k >= end - start + 1 ) ? undefined : itemToken( k + start ) ),
          // Length of this collection.
          length: () => ( end - start + 1 ),
          // Output this token collection as an array of their values or properties using input function — `f`.
          out: ( f ) => tokensOut( start, end, tokens, cache, f ),
          // Reduce executer.
          reduce: reduce
        };
      }
    );
  }; // colTokens()

  // <hr/>

  // ## Entity
  // **Item, Collection, and Selection APIs.**

  // ### itemEntity
  /**
   *
   * Makes item of the entity specified at `index`.
   *
   * @param {number} index The index of the entity, which is required to be returned as item entity.
   * @returns {object} containing applicable API methods.
   * @private
  */
  itemEntity = function ( index ) {
    // Finds the parent sentence item using the token at the begining of the entity.
    var sentence = function () {
      // Search using the token at the begining of the entity i.e. `entities[ index ][ 0 ]`.
      var k = search( entities[ index ][ 0 ], sentences );
      return itemSentence( sentences[ k ][ 0 ], sentences[ k ][ 1 ] );
    }; // sentence()

    return (
      {
        // Access the parent document.
        document: () => methods,
        // Markup this entity.
        markup: ( beginMarker, endMarker ) => markings.push( [ entities[ index ][ 0 ], entities[ index ][ 1 ], beginMarker, endMarker ] ),
        // Output this entity as object having `text` and `type` properties.
        out: eOut( index ),
        // Access the parent sentence.
        sentence: sentence,
        // Retun collection of tokens contained in this entity.
        tokens: colTokens( entities[ index ][ 0 ], entities[ index ][ 1 ] )
      }
    );
  }; // itemEntity()

  // ### colSelectedEntities
  /**
   *
   * Makes collection of entities identified by the `selectedEntities` array.
   *
   * @param {array} selectedEntities The array of selected entities, using which the
   * collection is made.
   * @returns {object} containing applicable API methods.
   * @private
  */
  colSelectedEntities = function ( selectedEntities ) {
    // Each iterator on `selectedEntities`.
    var each = function ( f ) {
      for ( let k = 0; k < selectedEntities.length; k += 1 ) {
        f( itemEntity( selectedEntities[ k ] ), k );
      }
    }; // each()

    // The filter() method creates a new collection with all entities that pass
    // the test implemented by the input function — `f`.
    var filter = function ( f ) {
      var filtered = [];
      for ( let k = 0; k < selectedEntities.length; k += 1 ) {
        if ( f( itemEntity( selectedEntities[ k ] ), k ) ) filtered.push( selectedEntities[ k ] );
      }
      return colSelectedEntities( filtered );
    }; // filter()

    // Executes the reducer function — `f` on each element of `selectedEntities` array.
    var reduce = function ( f, initValue ) {
      var returnValue = initValue;
      for ( let k = 0; k < selectedEntities.length; k += 1 ) {
        returnValue = f( returnValue, itemEntity( selectedEntities[ k ] ), k, selectedEntities.length );
      }
      return returnValue;
    }; // reduce()

    return (
      {
        // Iterator.
        each: each,
        // Filter.
        filter: filter,
        // Item at `k`th index. If `k` is outside valid range, return `undefined` like JS.
        itemAt: ( k ) => ( ( k < 0 || k >= selectedEntities.length ) ? undefined : itemEntity( selectedEntities[ k ] ) ),
        // Number of selected entities.
        length: () => ( selectedEntities.length ),
        // Output this collectionn of selected of entities as an array of objects; where each object has `text` and `type` properties.
        out: () => selEntitiesOut( selectedEntities, entities, tokens, cache ),
        // Reduce executor.
        reduce: reduce
      }
    );
  }; // colSelectedEntities()

  // ### colEntities
  /**
   *
   * Makes collection of entities beginning from `start` index to `end` index.
   *
   * @param {number} start The start index.
   * @param {number} end The end index.
   * @returns {object} containing applicable API methods.
   * @private
  */
  colEntities = function () {
    // Each iterator on this collection.
    var each = function ( f ) {
      for ( let k = 0; k < entities.length; k += 1 ) {
        f( itemEntity( k ), k );
      }
    }; // each()

    // The filter() method creates a new collection with all entities that pass
    // the test implemented by the input function — `f`.
    var filter = function ( f ) {
      var filtered = [];
      for ( let k = 0; k < entities.length; k += 1 ) {
        // Use relative indexing by adding `start` from `k`.
        if ( f( itemEntity( k ), k ) ) filtered.push( k );
      }
      return colSelectedEntities( filtered );
    }; // filter()

    // Executes the reducer function — `f` on each element this collection.
    var reduce = function ( f, initValue ) {
      var returnValue = initValue;
      for ( let k = 0; k < entities.length; k += 1 ) {
        returnValue = f( returnValue, itemEntity( k ), k, entities.length );
      }
      return returnValue;
    }; // reduce()

    return {
      // Iterator.
      each: each,
      // Filter.
      filter: filter,
      // Item at `k`th index. If `k` is outside valid range, return `undefined` like JS.
      itemAt: ( k ) => ( ( k < 0 || k >= entities.length ) ? undefined : itemEntity( k ) ),
      // Length of this collection.
      length: () => ( entities.length ),
      // Output this collection of entities as an array of objects; where each object has `text` and `type` properties.
      out: () => entitiesOut( entities, tokens, cache ),
      // Reduce executer.
      reduce: reduce
     };
  }; // colEntities()

  // <hr/>

  // ## Sentence
  // **Item, Collection, and Selection APIs.**

  // ### itemSentence
  /**
   *
   * Makes item of the sentence specified by span `start` — `end`.
   *
   * @param {number} start The start index of the token from where sentence begins.
   * @param {number} end The end index of the token at which sentence ends.
   * @returns {object} containing applicable API methods.
   * @private
  */
  itemSentence = function ( start, end ) {
    return (
      {
        // Access the parent document.
        document: () => methods,
        // Markup this sentence.
        markup: ( beginMarker, endMarker ) => markings.push( [ start, end, beginMarker, endMarker ] ),
        // Output this sentence as text.
        out: out( start, end ),
        // Outputs the collection of entities, if any, contained in this sentence.
        entities: () => colSelectedEntities( containedEntities( entities, start, end ) ),
        // Outputs the collection of tokens in this sentence.
        tokens: colTokens( start, end )
      }
    );
  }; // itemSentence()

  // ### colSentences
  /**
   *
   * Makes collection of sentence in this document.
   *
   * @returns {object} containing applicable API methods.
   * @private
  */
  colSentences = function () {
    // Each iterator on this collection.
    var each = function ( f ) {
      for ( let k = 0; k < sentences.length; k += 1 ) {
        f( itemSentence( sentences[ k ][ 0 ], sentences[ k ][ 1 ] ), k );
      }
    }; // each()

    return {
      // Iterator.
      each: each,
      // Item at `k`th index. If `k` is outside valid range, return `undefined` like JS.
      itemAt: ( k ) => ( ( k < 0 || k >= sentences.length ) ? undefined : itemSentence( sentences[ k ][ 0 ], sentences[ k ][ 1 ] ) ),
      // Length of this collection.
      length: () => ( sentences.length ),
      // Output this collection of sentences as an array of strings.
      out: () => sentencesOut( sentences, tokens, cache ),
     };
  }; // colSentences()

  // <hr/>

  // ## Others

  // ### isLexeme
  /**
   *
   * Tests if the `text` is a valid lexeme or not.
   *
   * @param {string} text to be added as token.
   * @returns {boolean} `truthy` if `text` is a valid lexeme otherwise `falsy`.
   * @private
  */
  isLexeme = function ( text ) {
    // Return `truthy` if the text is valid i.e. found. Note for `$%^OOV^%$`, it returns
    // `0` i.e. `falsy`!
    return cache.lookup( text );
  }; // isLexeme()

  var similarity = function ( aDoc ) {
    const v1 = aDoc.vector();
    const ln1 = aDoc.l2Norm();

    const v2 = docData.vector;
    const ln2 = docData.l2Norm;

    let sum = 0;
    for ( let i = 0; i < 100; i += 1 ) {
      sum += v1[ i ] * v2[ i ];
    }
    return +( sum / ( ln1 * ln2 ) ).toFixed( 6 );
  }; // similarity()

  // <hr/>

  // Published chainable methods.
  methods.entities = colEntities;
  methods.isLexeme = isLexeme;
  methods.isOOV = cache.isOOV;
  methods.markedUpText = () => markedUpText( tokens, markings, value );
  methods.out = out( 0, docData.numOfTokens - 1 );
  methods.sentences = colSentences;
  methods.tokens = colTokens( 0, docData.numOfTokens - 1 );

  methods.printTokens = () => printTokens( tokens, cache );
  // NOTE: patch must be removed/corrected.
  methods.sentiment = () => docData.sentiment;
  if ( docData.vector !== undefined ) {
    methods.vector = () => ( docData.vector.slice( 0 ) );
    methods.l2Norm = () => ( docData.l2Norm );
    methods.similarity = similarity;
  }

  return methods;
};

module.exports = doc;
