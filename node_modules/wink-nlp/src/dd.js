/* eslint-disable no-underscore-dangle */

var constants = require( './constants.js' );

// Size of a single token.
var tkSize = constants.tkSize;
// Bits reserved for `precedingSpaces`.
var bits4PrecedingSpace = constants.bits4PrecedingSpace;
// Size of a single expansion.
var xpSize = constants.xpSize;
// Bits reserved for `lemma`.
var bits4lemma = constants.bits4lemma;
// Mask for extracting pos
var posMask = constants.posMask;
// The UNK!
var UNK = constants.UNK;

var docData = function ( data ) {
  // Extract frequently referred data elements:
  // Extract `cache`.
  var cache = data.cache;
  // Extract `tokens`.
  var tokens = data.tokens;

  // Returned!
  var methods = Object.create( null );

  // ## addToken
  /**
   *
   * It first creates a new lexeme entry into the `cache` and then this entry
   * is pushed into the `tokens` array alongwith the `precedingSpaces` and
   * rest of the token properties are initialized to `0`.
   *
   * @param {string} text to be added as token.
   * @param {string} category of the token.
   * @param {number} precedingSpaces to the `text` as parsed by tokenizer.
   * @param {number[]} tokens, where the token is added.
   * @returns {boolean} always `true`.
   * @private
  */
  var addToken = function ( text, category, precedingSpaces ) {
    tokens.push( cache.add( text, category ), precedingSpaces, 0, 0 );
    return true;
  }; // addToken()

  // ## addTokenIfInCache
  /**
   *
   * Adds a token corresponding to the input `text` if it is found in cache i.e.
   * not an OOV. The addition process ensures the following:
   * 1. Preceding spaces are added.
   * 2. If text is a contraction, it expansions are added. Since expansins
   * consists of lexeme, normal, lemma and pos, all of these are added to the
   * token structure.
   *
   * @param {string} text to be added as token.
   * @param {number} precedingSpaces to the `text` as parsed by tokenizer.
   * @returns {boolean} `truthy` if `text` is found in cache otherwise `falsy`.
   * @private
  */
  var addTokenIfInCache = function ( text, precedingSpaces ) {
    // The array `tokenIndex` will contain 1-element if `text` is not a predefined
    // contraction; otherwise it will contain `n x 4` elements, where `n` is the
    // number of expansions.
    var tokenIndex = cache.lookup( text );
    // Temp for preceding space in case of contarction.
    var ps;
    // Temp for lemma & pos.
    var lemma, pos;

    // `UNK` means 0 or `falsy`; it flags that token has not been added.
    if ( tokenIndex === null ) return UNK;

    if ( tokenIndex.length === 1 ) {
      tokens.push( tokenIndex[ 0 ], precedingSpaces, 0, 0 );
    } else {
      // Contraction, itereate through each expansion.
      for ( let k = 0; k < tokenIndex.length; k += xpSize ) {
        // The `precedingSpaces` will be 0 except for the first expansion.
        ps = ( k === 0 ) ? precedingSpaces : 0;
        // Concatenate pointer to normal contained in `xpansions` with preceding
        // spaces.
        ps |= ( tokenIndex[ k + 1 ] << bits4PrecedingSpace ); // eslint-disable-line no-bitwise
        // Lemma & POS are fixed mostly for all contractions.
        lemma = tokenIndex[ k + 2 ];
        pos   = tokenIndex[ k + 3 ];
        // Add token; annotations may be filled later in the pipeline.
        tokens.push( tokenIndex[ k ], ps, ( lemma | ( pos << bits4lemma ) ), 0 ); // eslint-disable-line no-bitwise
      }
    }
    // Return `truthy`, indicating that token(s) has been added successfully.
    return 99;
  }; // addTokenIfInCache()

  // ## setPoS
  /**
   *
   * Sets the pos for the given token's index using the input `pos`; if the pos
   * is undefined then the most likely pos from the lexeme is used.
   *
   * @param {number} ti token's index for which pos needs to be set.
   * @param {number} pos index, if undefined then most likely pos' index is used.
   * @returns {number} index of the pos value set.
   * @private
  */
  var setPoS = function ( ti, pos ) {
    // Actual Index!
    var ai = ti * tkSize;
    // Use most likely pos if the incoming pos is undefined.
    var thePoS = ( pos === undefined ) ? cache.posOf( tokens[ ai ] ) : pos;
    // Initialize the value of pos to `0`.
    tokens[ ai + 2 ] &=  ~( posMask ); // eslint-disable-line no-bitwise
    // Now set the value by ORing the pos value.
    tokens[ ai + 2 ] |=  ( thePoS ) << bits4lemma; // eslint-disable-line no-bitwise
    // Return the set value
    return thePoS;
  }; // setPoS()

  // ## isLexeme
  /**
   *
   * Tests if the `text` is a valid lexeme or not.
   *
   * @param {string} text to be added as token.
   * @returns {boolean} `truthy` if `text` is a valid lexeme otherwise `falsy`.
   * @private
  */
  var isLexeme = function ( text ) {
    // Return `truthy` if the text is valid i.e. found. Note for `$%^OOV^%$`, it returns
    // `0` i.e. `falsy`!
    return cache.lookup( text );
  }; // isLexeme()

  var clean = function () {
    tokens = null;
  }; // clean()

  methods._addToken = addToken;
  methods._addTokenIfInCache = addTokenIfInCache;
  methods.setPoS = setPoS;
  methods.isLexeme = isLexeme;
  methods.clean = clean;

  return methods;
}; // docData()

module.exports = docData;
